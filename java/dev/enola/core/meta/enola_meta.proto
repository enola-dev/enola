// SPDX-License-Identifier: Apache-2.0
//
// Copyright 2023-2024 The Enola <https://enola.dev> Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

syntax = "proto3";

package dev.enola.core.meta;

import "google/protobuf/empty.proto";
import "java/dev/enola/core/enola_core.proto";
import "java/dev/enola/core/enola_ext.proto";

option java_string_check_utf8 = true;
option java_package = "dev.enola.core.meta.proto";
option java_multiple_files = true;
option go_package = "dev/enola/core/meta";

message Import {
  // URLs from where to load additional referenced Types.
  repeated string types = 1 [(dev.enola.type) = "enola.dev/url"];

  // TODO repeated string protos = 2;
  // TODO repeated string json_schemas = 2;
}

// Types are a collection of enola:dev.enola.core.meta.Type.
//
// This is kind of like a
// https://en.wikipedia.org/wiki/Domain_of_discourse#Universe_of_discourse
// or the https://en.wikipedia.org/wiki/Universe_(mathematics).
message Types {
  // TODO Implement, with @Test! Import import = 1;
  repeated Type types = 7;
}

message Type {
  // Unique ID of this Type.
  // For example, "d19974d6-0695-458d-bdd4-3ad89578db92".
  //
  // This "provides a relatively short yet unambiguous way to refer to a type",
  // as "fully-qualified type names may be large and waste space when
  // transmitted on the wire", and it "lets programmers change the symbolic name
  // while keeping a fixed ID" (inspired by
  // https://capnproto.org/language.html#unique-ids).
  //
  // It's recommended that this is set by the human author of the Type,
  // but if it's not, it will be automatically generated by hashing the name.
  // (This defeats the purpose of a "permanent" ID - but it's at least possible
  // to set it later, if a name is ever changed.)
  //
  // TODO "Nicely render" this in the Web UI, using dev.enola.core.ByteSeq.
  // TODO Do we *really* this, actually?
  // bytes id = 1 [(dev.enola.type) = "enola.dev/id"];

  // Short technical name of this Type.
  // Must be unique within the environment this Enola instance operates.
  // Publicly, using something that looks like an IRI/URI/URL is a simple way
  // for uniqueness. For example, "your.org/something" (which is technically a
  // relative URI, by chance). This string is NOT (necessarily) a valid URL;
  // e.g. you (generally) cannot "http GET your.org/something". As a convenience
  // for humans which type this into their web browser, your.org MAY set up a
  // "redirector" which responds with a 30x to somewhere "interesting" for a
  // human (not a machine), but that's just "nice", nothing more. Enola will
  // never use it as anything else than simply a unique string.
  string name = 2 [(dev.enola.type) = "enola.dev/gun"];

  // URL of this Type.
  // For example, "https://demo.enola.dev/type/enola.dev/Person".
  // You *CAN* http GET this URL. An Enola server will return a HTML page or
  // JSON or something. This is NOT set by the author of the Type, but at
  // runtime. It is based on the name.
  // TODO string url = 3 [(dev.enola.type) = "enola.dev/url"];

  // URI Template of instances of this Type.
  // For example, "hello/{message}" - where the parameter "message" refers to a
  // property; so instances would be e.g. "hello/world" and "hello/planets".
  // TODO Rename Type.uri to iri_template! (Because that's what this really is.)
  string uri = 4 [(dev.enola.type) = "enola.dev/uri-template"];

  // Properties of this Type.
  // TODO This needs to be Reference to a Property, not a contained Property...
  // TODO TBD! map<string, Property> properties = 5;

  // Human readable label of this type, may be several words, any case.
  // This is a map where the key is an IETF [BCP
  // 47](https://www.rfc-editor.org/info/bcp47) "language code" (like "en" or
  // "de-CH") and the value is text in that language. These can easily be
  // changed at any time without breaking anything in Enola.
  map<string, string> labels = 20 [(dev.enola.type) = "enola.dev/mls"];

  // Documentation description (as URL; either absolute, or URL relative to the
  // model's location - from where a UI will serve it).
  // TODO Is this a [(dev.enola.type) = "enola.dev/url"]? Really??
  string doc = 21 [(dev.enola.type) = "enola.dev/url"];

  // The Emoji shown as prefix to the label in UIs, if there is no logo.
  // This is not necessarily unique.
  string emoji = 22 [(dev.enola.type) = "https://enola.dev/emoji"];

  // Logo (as URL; either absolute, or URL relative to the model's location -
  // from where a UI will serve it).
  string logo_url = 23 [(dev.enola.type) = "enola.dev/url"];

  // TODO Replace with... Type reference?!? Whoa.
  oneof schema {
    // EntityKind.
    // This is from the original Enola design, and may later be removed.
    // TODO Should this really be embedded? Really? Probably better an ID as
    // reference? Good test!
    // string entity_kind = 10 [(dev.enola.type) = "enola.dev/EntityKind"];
    EntityKind legacy = 30;

    // Protocol Buffers Message.
    // For example, "google.protobuf.Timestamp".
    // TODO We need to be able to "annotate" (?) Proto descriptors for LD...
    string proto = 31 [(dev.enola.type) = "enola.dev/proto"];

    // A "simple type" that "extends" a string.
    // This is useful to add "semantics" to strings; e.g. URL, Email, etc.
    google.protobuf.Empty string = 32;

    // A "binary" type, with "content" that's an (unstructured) bytes sequence.
    google.protobuf.Empty binary = 33;
  }

  // TODO Remove? repeated Connector connectors = 40;

  string java = 50;
  repeated string javas = 51;

  // TODO Verbs!
}

message Property {
  uint32 id = 1;

  // Type of Property, as Name of another Type.
  // TODO Re-consider this... this is wrong, because Property is Types sharable.
  // string type = 2 [(dev.enola.type) = "enola.dev/type"];

  // Link to something related.
  // Intended both for human consumption in a UI, as well as machine readable
  // linked data relationships. Typically a Template of an (HTML a/href-like)
  // HTTP URL, or enola: URI. Template parameters refer to other properties of
  // the Type.
  string link = 10 [(dev.enola.type) = "enola.dev/uri-template"];

  // Human readable label of this property, may be several words, any case.
  // This is a map where the key is an IETF [BCP
  // 47](https://www.rfc-editor.org/info/bcp47) "language code" (like "en" or
  // "de-CH") and the value is text in that language. These can easily be
  // changed at any time without breaking anything in Enola.
  map<string, string> labels = 20 [(dev.enola.type) = "enola.dev/mls"];

  // Documentation description (as URL; either absolute, or URL relative to the
  // model's location - from where a UI will serve it).
  // TODO Is this a [(dev.enola.type) = "enola.dev/url"]? Really??
  string doc = 21 [(dev.enola.type) = "enola.dev/url"];
}

message EntityKinds {
  repeated EntityKind kinds = 1;
}

// Kind of an Entity, as in message Entity.
message EntityKind {
  // ID.
  // The ns may be filled in by the reader, if omitted in *-model.textproto.
  // The entity is the name of THIS EntityKind! This is typically never changed
  // anymore after initial creation. The path contains' the segments' names
  // (here, whereas in Entity it's the "values").
  ID id = 1;

  // Human readable label of entity, may be several words, any case.
  // This can easily be changed at any time.
  string label = 2;

  // The Emoji shown as prefix to the name in UIs, if there is no logo.
  string emoji = 3;

  // Logo (as URL; either absolute, or URL relative to the model's textproto
  // file location - from where a UI will serve it).
  string logo_url = 4;

  // Documentation description (as URL; either absolute, or URL relative to the
  // model's textproto file location - from where a UI will serve it).
  string doc_url = 5;

  // Description of related Entities.
  // The string keys here match Entity#related's.
  map<string, EntityRelationship> related = 14;

  // Description of URL links.
  // The string keys here match Entity#links's.
  map<string, Link> link = 15;

  // Description of data about the Entity, in machine readable form.
  // The string keys here match Entity#data's.
  map<string, Data> data = 16;

  repeated Connector connectors = 20;

  // TODO Describe detailed "state machine"
  // TODO Build cool visualization of said state machine as fancy diagram
}

// Entity#related map model; its key is the same as this in EntityKind#related.
message EntityRelationship {
  // Human readable label, may be shown on a UI.
  string label = 2;

  // Short 1-2 sentences of description, may be shown on a UI e.g. as tooltip.
  string description = 3;

  // ID reference to another Entity.
  // This ID's ns/entity/paths fields can contain a template, like
  // Link#uri_template. Alternatively, this can be left empty, and set by
  // connectors.
  ID id = 4;

  // Tags.
  map<string, string> tags = 5;
}

// Entity#link map model; its key is the same as this in EntityKind#link.
message Link {
  // Human readable label, may be shown on a UI.
  string label = 2;

  // Short 1-2 sentences of description, may be shown on a UI e.g. as tooltip.
  string description = 3;

  // URI template, to create URL.
  // As an ID URI Template (RFC 6570); see
  // https://en.wikipedia.org/wiki/URI_Template.
  // The available variables are the ID's path parameters, as well as a special
  // proto.* which allows to declaratively create links out of the Any proto
  // (instead of coding link generation in the service; which is always still
  // also possible).
  string uri_template = 4;

  // Tags.
  map<string, string> tags = 5;

  /*
    TODO Consider if we should declare what to expect at the link?

    string media_type = 5;

    enum Kind {
      KIND_UNSPECIFIED = 0;
      KIND_PROTOBUF = 1;
      KIND_JSON = 2;
    }
    Kind kind = 5;
  */
}

message Data {
  // Human readable label, may be shown on a UI.
  string label = 2;

  // Short 1-2 sentences of description, may be shown on a UI e.g. as tooltip.
  string description = 3;

  // Tags.
  map<string, string> tags = 5;

  // The fully qualified name of the (root) Protocol Buffer Message; see
  // https://github.com/protocolbuffers/protobuf/blob/main/src/google/protobuf/any.proto
  string type_url = 6;
}

message Connector {
  oneof type {
    // Always fails with this error message (for testing, only).
    // TODO Remove this again? This was really useful in earlier testing, only.
    string error = 1;

    // Java class name for in-process connector on the Java classpath.
    string java_class = 2;

    // TODO java_guice lookup?

    FileSystemRepository fs = 4;

    // Invokes remote connector via gRPC.
    // The "connection string" here is a target endpoint in hostname:port
    // format. (It's NOT an URI, so there is no scheme:// nor any /path/ or
    // #fragment.)
    string grpc = 5;
  }
}

message FileSystemRepository {
  string path = 1;

  enum Format {
    FORMAT_UNSPECIFIED = 0;
    FORMAT_TEXTPROTO = 1;
    FORMAT_YAML = 2;
    FORMAT_JSON = 3;
  }
  Format format = 2;

  // TODO https://github.com/enola-dev/enola/issues/238
  // repeated string protos = 3;
}
