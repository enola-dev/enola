syntax = "proto3";

package dev.enola.core;

option java_string_check_utf8 = true;
option java_package = "dev.enola.core.proto";
option java_multiple_files = true;

import "google/protobuf/any.proto";
import "google/protobuf/timestamp.proto";

enum Status {
  STATUS_UNSPECIFIED     = 0;
  STATUS_OK              = 200;
  STATUS_OK_BUT_DEGRADED = 300;
  STATUS_NOK_DEPENDENCY  = 502;
  STATUS_NOK_ITSELF      = 503;
}

// ID of an object known to Enola.
// In text (string) form, it "looks" like an RFC 2396 Uniform Resource Identifier (URI, not URN),
// but this is just we want some "standard"-like format which humans are used to seeing.
// The real syntax is actually simpler and quite a bit more restricted,
// see https://en.wikipedia.org/wiki/Uniform_Resource_Identifier#Syntax:
//
// * The "scheme" is just a "namespace" in Enola, which typically aligns with RPC Service implementations.
// * The "authority" (//...) is not used (and IDs with them are rejected; see IDsTest.java).
// * The "path" is not actually a path, but just a name of a kind of entity within that scheme. It can contain slashes, but they are not interpreted.
// * The "query" (?...) is used to identify a specific entity (with a name or UUID or whatever; specific to each entity).
// * The "fragment" (#...) is not used (and IDs with them are rejected; see IDsTest.java).
//
// Things like a "cluster" or a "rack" or whatever "hierarchies" an entity may have are, by convention,
// not part of the entity (path), but represented as part of the query; for example:
// * k8s:pod?network=prod&context=demo&namespace=test&name=hello
//
// Note that IDs are not "unique", and 2 different IDs may refer to the same underlying object; for example:
// * k8s:pod?name=echoserver-6dfb6c7764-45gvk&...
// * k8s:pod?uid=561f1bec-f768-4c5b-b96e-37306d7f2f8a&...
//
// We permit RPC clients to specify the ID in either (oneof) string text or "broken down" parts form.
// This is simply for dev convenience in UX such as CLI or Web UIs, and to avoid the proliferation of incompatible parsers.
// The implementation validates the text, and rejects e.g. "demo:foo?bad=a=b" or "demo:foo?bad=a&bad=b".
// The string text oneof form is NOT "decoded" (incl. un-quoted) at all, simply "split" as-is.
message ID {
  oneof oneof {
    string text  = 1;
    Parts parts  = 2;
  }
  message Parts {
    string scheme = 1;
    string entity = 2;
    map<string, string> query = 3;
  }
}

message GetRequest {
  ID id = 1;

  // google.protobuf.Timestamp ts = 2;
  // google.protobuf.Timestamp start = 2;
  // google.protobuf.Timestamp end = 3;
  // google.protobuf.Duration granularity = 4;
}
message GetResponse {
  ID id = 1;
  google.protobuf.Timestamp ts = 2;
  Status status = 3;
  repeated string depends_on = 4;
  string is_owned_by = 5;
  google.protobuf.Any proto = 6;
}

message QueryAvailableEntitiesRequest {
  // Parts can be empty;
  // if no scheme, returns all schemes;
  // if scheme but not no entity, returns all entities of the scheme;
  // if scheme and entity, returns all available query parameter names (without values).
  ID.Parts id_parts = 1;
}
message QueryAvailableEntitiesResponse {
  repeated ID id = 1;
}

service EnolaService {
  rpc Get(GetRequest) returns (GetResponse) {}
  rpc QueryAvailableEntities(QueryAvailableEntitiesRequest) returns (QueryAvailableEntitiesResponse) {}
}
